from _typeshed import Incomplete
from django.contrib.contenttypes.models import ContentType as ContentType
from django.core import checks as checks
from django.core.exceptions import FieldDoesNotExist as FieldDoesNotExist, ObjectDoesNotExist as ObjectDoesNotExist
from django.db import DEFAULT_DB_ALIAS as DEFAULT_DB_ALIAS, models as models, router as router, transaction as transaction
from django.db.models import DO_NOTHING as DO_NOTHING, ForeignObject as ForeignObject, ForeignObjectRel as ForeignObjectRel
from django.db.models.base import ModelBase as ModelBase, make_foreign_order_accessors as make_foreign_order_accessors
from django.db.models.fields import Field as Field
from django.db.models.fields.mixins import FieldCacheMixin as FieldCacheMixin
from django.db.models.fields.related import ReverseManyToOneDescriptor as ReverseManyToOneDescriptor, lazy_related_operation as lazy_related_operation
from django.db.models.query_utils import PathInfo as PathInfo
from django.db.models.sql import AND as AND
from django.db.models.sql.where import WhereNode as WhereNode
from django.db.models.utils import AltersData as AltersData
from django.utils.deprecation import RemovedInDjango60Warning as RemovedInDjango60Warning
from django.utils.functional import cached_property as cached_property

class GenericForeignKey(FieldCacheMixin, Field):
    many_to_many: bool
    many_to_one: bool
    one_to_many: bool
    one_to_one: bool
    ct_field: Incomplete
    fk_field: Incomplete
    for_concrete_model: Incomplete
    is_relation: bool
    def __init__(self, ct_field: str = 'content_type', fk_field: str = 'object_id', for_concrete_model: bool = True) -> None: ...
    def contribute_to_class(self, cls, name, **kwargs) -> None: ...
    def get_attname_column(self): ...
    def get_filter_kwargs_for_object(self, obj): ...
    def get_forward_related_filter(self, obj): ...
    def check(self, **kwargs): ...
    def cache_name(self): ...
    def get_content_type(self, obj: Incomplete | None = None, id: Incomplete | None = None, using: Incomplete | None = None, model: Incomplete | None = None): ...
    def get_prefetch_queryset(self, instances, queryset: Incomplete | None = None): ...
    def get_prefetch_querysets(self, instances, querysets: Incomplete | None = None): ...
    def __get__(self, instance, cls: Incomplete | None = None): ...
    def __set__(self, instance, value) -> None: ...

class GenericRel(ForeignObjectRel):
    def __init__(self, field, to, related_name: Incomplete | None = None, related_query_name: Incomplete | None = None, limit_choices_to: Incomplete | None = None) -> None: ...

class GenericRelation(ForeignObject):
    auto_created: bool
    empty_strings_allowed: bool
    many_to_many: bool
    many_to_one: bool
    one_to_many: bool
    one_to_one: bool
    rel_class = GenericRel
    mti_inherited: bool
    object_id_field_name: Incomplete
    content_type_field_name: Incomplete
    for_concrete_model: Incomplete
    def __init__(self, to, object_id_field: str = 'object_id', content_type_field: str = 'content_type', for_concrete_model: bool = True, related_query_name: Incomplete | None = None, limit_choices_to: Incomplete | None = None, **kwargs) -> None: ...
    def check(self, **kwargs): ...
    to_fields: Incomplete
    def resolve_related_fields(self): ...
    def get_path_info(self, filtered_relation: Incomplete | None = None): ...
    def get_reverse_path_info(self, filtered_relation: Incomplete | None = None): ...
    def value_to_string(self, obj): ...
    model: Incomplete
    def contribute_to_class(self, cls, name, **kwargs) -> None: ...
    def set_attributes_from_rel(self) -> None: ...
    def get_internal_type(self): ...
    def get_content_type(self): ...
    def get_extra_restriction(self, alias, remote_alias): ...
    def bulk_related_objects(self, objs, using=...): ...

class ReverseGenericManyToOneDescriptor(ReverseManyToOneDescriptor):
    def related_manager_cls(self): ...

def create_generic_related_manager(superclass, rel): ...
