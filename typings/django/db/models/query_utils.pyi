from _typeshed import Incomplete
from collections.abc import Generator
from django.core.exceptions import FieldError as FieldError
from django.db import DEFAULT_DB_ALIAS as DEFAULT_DB_ALIAS, DatabaseError as DatabaseError, connections as connections
from django.db.models.constants import LOOKUP_SEP as LOOKUP_SEP
from django.utils import tree as tree
from django.utils.functional import cached_property as cached_property
from django.utils.hashable import make_hashable as make_hashable
from typing import NamedTuple

logger: Incomplete

class PathInfo(NamedTuple):
    from_opts: Incomplete
    to_opts: Incomplete
    target_fields: Incomplete
    join_field: Incomplete
    m2m: Incomplete
    direct: Incomplete
    filtered_relation: Incomplete

def subclasses(cls) -> Generator[Incomplete, Incomplete]: ...

class Q(tree.Node):
    AND: str
    OR: str
    XOR: str
    default = AND
    conditional: bool
    def __init__(self, *args, _connector: Incomplete | None = None, _negated: bool = False, **kwargs) -> None: ...
    def __or__(self, other): ...
    def __and__(self, other): ...
    def __xor__(self, other): ...
    def __invert__(self): ...
    def resolve_expression(self, query: Incomplete | None = None, allow_joins: bool = True, reuse: Incomplete | None = None, summarize: bool = False, for_save: bool = False): ...
    def flatten(self) -> Generator[Incomplete, Incomplete]: ...
    def check(self, against, using=...): ...
    def deconstruct(self): ...
    def identity(self): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def referenced_base_fields(self): ...

class DeferredAttribute:
    field: Incomplete
    def __init__(self, field) -> None: ...
    def __get__(self, instance, cls: Incomplete | None = None): ...

class class_or_instance_method:
    class_method: Incomplete
    instance_method: Incomplete
    def __init__(self, class_method, instance_method) -> None: ...
    def __get__(self, instance, owner): ...

class RegisterLookupMixin:
    def get_class_lookups(cls): ...
    def get_instance_lookups(self): ...
    get_lookups: Incomplete
    get_class_lookups: Incomplete
    def get_lookup(self, lookup_name): ...
    def get_transform(self, lookup_name): ...
    @staticmethod
    def merge_dicts(dicts): ...
    def register_class_lookup(cls, lookup, lookup_name: Incomplete | None = None): ...
    instance_lookups: Incomplete
    def register_instance_lookup(self, lookup, lookup_name: Incomplete | None = None): ...
    register_lookup: Incomplete
    register_class_lookup: Incomplete

def select_related_descend(field, restricted, requested, select_mask): ...
def refs_expression(lookup_parts, annotations): ...
def check_rel_lookup_compatibility(model, target_opts, field): ...

class FilteredRelation:
    relation_name: Incomplete
    alias: Incomplete
    condition: Incomplete
    resolved_condition: Incomplete
    def __init__(self, relation_name, *, condition=...) -> None: ...
    def __eq__(self, other): ...
    def clone(self): ...
    def relabeled_clone(self, change_map): ...
    def resolve_expression(self, query, reuse, *args, **kwargs): ...
    def as_sql(self, compiler, connection): ...
