from _typeshed import Incomplete
from collections.abc import Generator
from django.conf import settings as settings
from django.core import exceptions as exceptions
from django.db import DJANGO_VERSION_PICKLE_KEY as DJANGO_VERSION_PICKLE_KEY, IntegrityError as IntegrityError, NotSupportedError as NotSupportedError, connections as connections, router as router, transaction as transaction
from django.db.models import AutoField as AutoField, DateField as DateField, DateTimeField as DateTimeField, Field as Field, sql as sql
from django.db.models.constants import LOOKUP_SEP as LOOKUP_SEP, OnConflict as OnConflict
from django.db.models.deletion import Collector as Collector
from django.db.models.expressions import Case as Case, F as F, Value as Value, When as When
from django.db.models.functions import Cast as Cast, Trunc as Trunc
from django.db.models.query_utils import FilteredRelation as FilteredRelation, Q as Q
from django.db.models.sql.constants import CURSOR as CURSOR, GET_ITERATOR_CHUNK_SIZE as GET_ITERATOR_CHUNK_SIZE
from django.db.models.utils import AltersData as AltersData, create_namedtuple_class as create_namedtuple_class, resolve_callables as resolve_callables
from django.utils import timezone as timezone
from django.utils.deprecation import RemovedInDjango60Warning as RemovedInDjango60Warning
from django.utils.functional import cached_property as cached_property, partition as partition

MAX_GET_RESULTS: int
REPR_OUTPUT_SIZE: int

class BaseIterable:
    queryset: Incomplete
    chunked_fetch: Incomplete
    chunk_size: Incomplete
    def __init__(self, queryset, chunked_fetch: bool = False, chunk_size=...) -> None: ...
    def __aiter__(self): ...

class ModelIterable(BaseIterable):
    def __iter__(self): ...

class RawModelIterable(BaseIterable):
    def __iter__(self): ...

class ValuesIterable(BaseIterable):
    def __iter__(self): ...

class ValuesListIterable(BaseIterable):
    def __iter__(self): ...

class NamedValuesListIterable(ValuesListIterable):
    def __iter__(self): ...

class FlatValuesListIterable(BaseIterable):
    def __iter__(self): ...

class QuerySet(AltersData):
    model: Incomplete
    def __init__(self, model: Incomplete | None = None, query: Incomplete | None = None, using: Incomplete | None = None, hints: Incomplete | None = None) -> None: ...
    @property
    def query(self): ...
    @query.setter
    def query(self, value) -> None: ...
    def as_manager(cls): ...
    as_manager: Incomplete
    def __deepcopy__(self, memo): ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __aiter__(self): ...
    def __bool__(self) -> bool: ...
    def __getitem__(self, k): ...
    def __class_getitem__(cls, *args, **kwargs): ...
    def __and__(self, other): ...
    def __or__(self, other): ...
    def __xor__(self, other): ...
    def iterator(self, chunk_size: Incomplete | None = None): ...
    async def aiterator(self, chunk_size: int = 2000) -> Generator[Incomplete]: ...
    def aggregate(self, *args, **kwargs): ...
    async def aaggregate(self, *args, **kwargs): ...
    def count(self): ...
    async def acount(self): ...
    def get(self, *args, **kwargs): ...
    async def aget(self, *args, **kwargs): ...
    def create(self, **kwargs): ...
    async def acreate(self, **kwargs): ...
    def bulk_create(self, objs, batch_size: Incomplete | None = None, ignore_conflicts: bool = False, update_conflicts: bool = False, update_fields: Incomplete | None = None, unique_fields: Incomplete | None = None): ...
    async def abulk_create(self, objs, batch_size: Incomplete | None = None, ignore_conflicts: bool = False, update_conflicts: bool = False, update_fields: Incomplete | None = None, unique_fields: Incomplete | None = None): ...
    def bulk_update(self, objs, fields, batch_size: Incomplete | None = None): ...
    async def abulk_update(self, objs, fields, batch_size: Incomplete | None = None): ...
    def get_or_create(self, defaults: Incomplete | None = None, **kwargs): ...
    async def aget_or_create(self, defaults: Incomplete | None = None, **kwargs): ...
    def update_or_create(self, defaults: Incomplete | None = None, create_defaults: Incomplete | None = None, **kwargs): ...
    async def aupdate_or_create(self, defaults: Incomplete | None = None, create_defaults: Incomplete | None = None, **kwargs): ...
    def earliest(self, *fields): ...
    async def aearliest(self, *fields): ...
    def latest(self, *fields): ...
    async def alatest(self, *fields): ...
    def first(self): ...
    async def afirst(self): ...
    def last(self): ...
    async def alast(self): ...
    def in_bulk(self, id_list: Incomplete | None = None, *, field_name: str = 'pk'): ...
    async def ain_bulk(self, id_list: Incomplete | None = None, *, field_name: str = 'pk'): ...
    def delete(self): ...
    async def adelete(self): ...
    def update(self, **kwargs): ...
    async def aupdate(self, **kwargs): ...
    def exists(self): ...
    async def aexists(self): ...
    def contains(self, obj): ...
    async def acontains(self, obj): ...
    def explain(self, *, format: Incomplete | None = None, **options): ...
    async def aexplain(self, *, format: Incomplete | None = None, **options): ...
    def raw(self, raw_query, params=(), translations: Incomplete | None = None, using: Incomplete | None = None): ...
    def values(self, *fields, **expressions): ...
    def values_list(self, *fields, flat: bool = False, named: bool = False): ...
    def dates(self, field_name, kind, order: str = 'ASC'): ...
    def datetimes(self, field_name, kind, order: str = 'ASC', tzinfo: Incomplete | None = None): ...
    def none(self): ...
    def all(self): ...
    def filter(self, *args, **kwargs): ...
    def exclude(self, *args, **kwargs): ...
    def complex_filter(self, filter_obj): ...
    def union(self, *other_qs, all: bool = False): ...
    def intersection(self, *other_qs): ...
    def difference(self, *other_qs): ...
    def select_for_update(self, nowait: bool = False, skip_locked: bool = False, of=(), no_key: bool = False): ...
    def select_related(self, *fields): ...
    def prefetch_related(self, *lookups): ...
    def annotate(self, *args, **kwargs): ...
    def alias(self, *args, **kwargs): ...
    def order_by(self, *field_names): ...
    def distinct(self, *field_names): ...
    def extra(self, select: Incomplete | None = None, where: Incomplete | None = None, params: Incomplete | None = None, tables: Incomplete | None = None, order_by: Incomplete | None = None, select_params: Incomplete | None = None): ...
    def reverse(self): ...
    def defer(self, *fields): ...
    def only(self, *fields): ...
    def using(self, alias): ...
    @property
    def ordered(self): ...
    @property
    def db(self): ...
    def resolve_expression(self, *args, **kwargs): ...

class InstanceCheckMeta(type):
    def __instancecheck__(self, instance): ...

class EmptyQuerySet(metaclass=InstanceCheckMeta):
    def __init__(self, *args, **kwargs) -> None: ...

class RawQuerySet:
    raw_query: Incomplete
    model: Incomplete
    query: Incomplete
    params: Incomplete
    translations: Incomplete
    def __init__(self, raw_query, model: Incomplete | None = None, query: Incomplete | None = None, params=(), translations: Incomplete | None = None, using: Incomplete | None = None, hints: Incomplete | None = None) -> None: ...
    def resolve_model_init_order(self): ...
    def prefetch_related(self, *lookups): ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __iter__(self): ...
    def __aiter__(self): ...
    def iterator(self) -> Generator[Incomplete, Incomplete]: ...
    def __getitem__(self, k): ...
    @property
    def db(self): ...
    def using(self, alias): ...
    def columns(self): ...
    def model_fields(self): ...

class Prefetch:
    prefetch_through: Incomplete
    prefetch_to: Incomplete
    queryset: Incomplete
    to_attr: Incomplete
    def __init__(self, lookup, queryset: Incomplete | None = None, to_attr: Incomplete | None = None) -> None: ...
    def add_prefix(self, prefix) -> None: ...
    def get_current_prefetch_to(self, level): ...
    def get_current_to_attr(self, level): ...
    def get_current_queryset(self, level): ...
    def get_current_querysets(self, level): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

def normalize_prefetch_lookups(lookups, prefix: Incomplete | None = None): ...
def prefetch_related_objects(model_instances, *related_lookups) -> None: ...
async def aprefetch_related_objects(model_instances, *related_lookups): ...
def get_prefetcher(instance, through_attr, to_attr): ...
def prefetch_one_level(instances, prefetcher, lookup, level): ...

class RelatedPopulator:
    db: Incomplete
    cols_start: Incomplete
    cols_end: Incomplete
    init_list: Incomplete
    reorder_for_init: Incomplete
    model_cls: Incomplete
    pk_idx: Incomplete
    related_populators: Incomplete
    local_setter: Incomplete
    remote_setter: Incomplete
    def __init__(self, klass_info, select, db) -> None: ...
    def populate(self, row, from_obj) -> None: ...

def get_related_populators(klass_info, select, db): ...
