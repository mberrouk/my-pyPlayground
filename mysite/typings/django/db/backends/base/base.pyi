"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from django.db.backends.base.validation import BaseDatabaseValidation
from django.utils.asyncio import async_unsafe
from django.utils.functional import cached_property

NO_DB_ALIAS = ...
RAN_DB_VERSION_CHECK = ...
logger = ...
class BaseDatabaseWrapper:
    """Represent a database connection."""
    data_types = ...
    data_types_suffix = ...
    data_type_check_constraints = ...
    ops = ...
    vendor = ...
    display_name = ...
    SchemaEditorClass = ...
    client_class = ...
    creation_class = ...
    features_class = ...
    introspection_class = ...
    ops_class = ...
    validation_class = BaseDatabaseValidation
    queries_limit = ...
    def __init__(self, settings_dict, alias=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def ensure_timezone(self): # -> Literal[False]:
        """
        Ensure the connection's timezone is set to `self.timezone_name` and
        return whether it changed or not.
        """
        ...
    
    @cached_property
    def timezone(self): # -> timezone | ZoneInfo | None:
        """
        Return a tzinfo of the database connection time zone.

        This is only used when time zone support is enabled. When a datetime is
        read from the database, it is always returned in this time zone.

        When the database backend supports time zones, it doesn't matter which
        time zone Django uses, as long as aware datetimes are used everywhere.
        Other users connecting to the database can choose their own time zone.

        When the database backend doesn't support time zones, the time zone
        Django uses may be constrained by the requirements of other users of
        the database.
        """
        ...
    
    @cached_property
    def timezone_name(self): # -> Any | Literal['UTC']:
        """
        Name of the time zone of the database connection.
        """
        ...
    
    @property
    def queries_logged(self): # -> Any | Literal[True]:
        ...
    
    @property
    def queries(self): # -> list[Any]:
        ...
    
    def get_database_version(self):
        """Return a tuple of the database's version."""
        ...
    
    def check_database_version_supported(self): # -> None:
        """
        Raise an error if the database version isn't supported by this
        version of Django.
        """
        ...
    
    def get_connection_params(self):
        """Return a dict of parameters suitable for get_new_connection."""
        ...
    
    def get_new_connection(self, conn_params):
        """Open a connection to the database."""
        ...
    
    def init_connection_state(self): # -> None:
        """Initialize the database connection settings."""
        ...
    
    def create_cursor(self, name=...):
        """Create a cursor. Assume that a connection is established."""
        ...
    
    @async_unsafe
    def connect(self): # -> None:
        """Connect to the database. Assume that the connection is closed."""
        ...
    
    def check_settings(self): # -> None:
        ...
    
    @async_unsafe
    def ensure_connection(self): # -> None:
        """Guarantee that a connection to the database is established."""
        ...
    
    @async_unsafe
    def cursor(self): # -> CursorDebugWrapper | CursorWrapper:
        """Create a cursor, opening a connection if necessary."""
        ...
    
    @async_unsafe
    def commit(self): # -> None:
        """Commit a transaction and reset the dirty flag."""
        ...
    
    @async_unsafe
    def rollback(self): # -> None:
        """Roll back a transaction and reset the dirty flag."""
        ...
    
    @async_unsafe
    def close(self): # -> None:
        """Close the connection to the database."""
        ...
    
    @async_unsafe
    def savepoint(self): # -> str | None:
        """
        Create a savepoint inside the current transaction. Return an
        identifier for the savepoint that will be used for the subsequent
        rollback or commit. Do nothing if savepoints are not supported.
        """
        ...
    
    @async_unsafe
    def savepoint_rollback(self, sid): # -> None:
        """
        Roll back to a savepoint. Do nothing if savepoints are not supported.
        """
        ...
    
    @async_unsafe
    def savepoint_commit(self, sid): # -> None:
        """
        Release a savepoint. Do nothing if savepoints are not supported.
        """
        ...
    
    @async_unsafe
    def clean_savepoints(self): # -> None:
        """
        Reset the counter used to generate unique savepoint ids in this thread.
        """
        ...
    
    def get_autocommit(self): # -> bool:
        """Get the autocommit state."""
        ...
    
    def set_autocommit(self, autocommit, force_begin_transaction_with_broken_autocommit=...): # -> None:
        """
        Enable or disable autocommit.

        The usual way to start a transaction is to turn autocommit off.
        SQLite does not properly start a transaction when disabling
        autocommit. To avoid this buggy behavior and to actually enter a new
        transaction, an explicit BEGIN is required. Using
        force_begin_transaction_with_broken_autocommit=True will issue an
        explicit BEGIN with SQLite. This option will be ignored for other
        backends.
        """
        ...
    
    def get_rollback(self): # -> bool:
        """Get the "needs rollback" flag -- for *advanced use* only."""
        ...
    
    def set_rollback(self, rollback): # -> None:
        """
        Set or unset the "needs rollback" flag -- for *advanced use* only.
        """
        ...
    
    def validate_no_atomic_block(self): # -> None:
        """Raise an error if an atomic block is active."""
        ...
    
    def validate_no_broken_transaction(self): # -> None:
        ...
    
    @contextmanager
    def constraint_checks_disabled(self): # -> Generator[None, Any, None]:
        """
        Disable foreign key constraint checking.
        """
        ...
    
    def disable_constraint_checking(self): # -> Literal[False]:
        """
        Backends can implement as needed to temporarily disable foreign key
        constraint checking. Should return True if the constraints were
        disabled and will need to be reenabled.
        """
        ...
    
    def enable_constraint_checking(self): # -> None:
        """
        Backends can implement as needed to re-enable foreign key constraint
        checking.
        """
        ...
    
    def check_constraints(self, table_names=...): # -> None:
        """
        Backends can override this method if they can apply constraint
        checking (e.g. via "SET CONSTRAINTS ALL IMMEDIATE"). Should raise an
        IntegrityError if any invalid foreign key references are encountered.
        """
        ...
    
    def is_usable(self):
        """
        Test if the database connection is usable.

        This method may assume that self.connection is not None.

        Actual implementations should take care not to raise exceptions
        as that may prevent Django from recycling unusable connections.
        """
        ...
    
    def close_if_health_check_failed(self): # -> None:
        """Close existing connection if it fails a health check."""
        ...
    
    def close_if_unusable_or_obsolete(self): # -> None:
        """
        Close the current connection if unrecoverable errors have occurred
        or if it outlived its maximum age.
        """
        ...
    
    @property
    def allow_thread_sharing(self): # -> bool:
        ...
    
    def inc_thread_sharing(self): # -> None:
        ...
    
    def dec_thread_sharing(self): # -> None:
        ...
    
    def validate_thread_sharing(self): # -> None:
        """
        Validate that the connection isn't accessed by another thread than the
        one which originally created it, unless the connection was explicitly
        authorized to be shared between threads (via the `inc_thread_sharing()`
        method). Raise an exception if the validation fails.
        """
        ...
    
    def prepare_database(self): # -> None:
        """
        Hook to do any database check or preparation, generally called before
        migrating a project or an app.
        """
        ...
    
    @cached_property
    def wrap_database_errors(self): # -> DatabaseErrorWrapper:
        """
        Context manager and decorator that re-throws backend-specific database
        exceptions using Django's common wrappers.
        """
        ...
    
    def chunked_cursor(self): # -> CursorDebugWrapper | CursorWrapper:
        """
        Return a cursor that tries to avoid caching in the database (if
        supported by the database), otherwise return a regular cursor.
        """
        ...
    
    def make_debug_cursor(self, cursor): # -> CursorDebugWrapper:
        """Create a cursor that logs all queries in self.queries_log."""
        ...
    
    def make_cursor(self, cursor): # -> CursorWrapper:
        """Create a cursor without debug logging."""
        ...
    
    @contextmanager
    def temporary_connection(self): # -> Generator[CursorDebugWrapper | CursorWrapper, Any, None]:
        """
        Context manager that ensures that a connection is established, and
        if it opened one, closes it to avoid leaving a dangling connection.
        This is useful for operations outside of the request-response cycle.

        Provide a cursor: with self.temporary_connection() as cursor: ...
        """
        ...
    
    def schema_editor(self, *args, **kwargs):
        """
        Return a new instance of this backend's SchemaEditor.
        """
        ...
    
    def on_commit(self, func, robust=...): # -> None:
        ...
    
    def run_and_clear_commit_hooks(self): # -> None:
        ...
    
    @contextmanager
    def execute_wrapper(self, wrapper): # -> Generator[None, Any, None]:
        """
        Return a context manager under which the wrapper is applied to suitable
        database query executions.
        """
        ...
    
    def copy(self, alias=...): # -> Self:
        """
        Return a copy of this connection.

        For tests that require two connections to the same database.
        """
        ...
    


