"""
This type stub file was generated by pyright.
"""

import threading
import unittest
from contextlib import contextmanager
from django.core.handlers.wsgi import WSGIHandler
from django.core.servers.basehttp import ThreadedWSGIServer, WSGIRequestHandler
from django.test.client import AsyncClient, Client
from django.test.utils import CaptureQueriesContext
from django.utils.functional import classproperty
from django.utils.version import PY311

"""
This type stub file was generated by pyright.
"""
logger = ...
__all__ = ("TestCase", "TransactionTestCase", "SimpleTestCase", "skipIfDBFeature", "skipUnlessDBFeature")
if not PY311:
    ...
def to_list(value):
    """Put value into a list if it's not already one."""
    ...

def is_pickable(obj):
    """
    Returns true if the object can be dumped and loaded through the pickle
    module.
    """
    ...

def assert_and_parse_html(self, html, user_msg, msg):
    ...

class _AssertNumQueriesContext(CaptureQueriesContext):
    def __init__(self, test_case, num, connection) -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback):
        ...
    


class _AssertTemplateUsedContext:
    def __init__(self, test_case, template_name, msg_prefix=..., count=...) -> None:
        ...
    
    def on_template_render(self, sender, signal, template, context, **kwargs):
        ...
    
    def test(self):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_value, traceback):
        ...
    


class _AssertTemplateNotUsedContext(_AssertTemplateUsedContext):
    def test(self):
        ...
    


class DatabaseOperationForbidden(AssertionError):
    ...


class _DatabaseFailure:
    def __init__(self, wrapped, message) -> None:
        ...
    
    def __call__(self):
        ...
    


class SimpleTestCase(unittest.TestCase):
    client_class = Client
    async_client_class = AsyncClient
    _overridden_settings = ...
    _modified_settings = ...
    databases = ...
    _disallowed_database_msg = ...
    _disallowed_connection_methods = ...
    @classmethod
    def setUpClass(cls):
        ...
    
    @classmethod
    def ensure_connection_patch_method(cls):
        ...
    
    def __call__(self, result=...):
        """
        Wrapper around default __call__ method to perform common Django test
        set up. This means that user-defined TestCases aren't required to
        include a call to super().setUp().
        """
        ...
    
    def __getstate__(self):
        """
        Make SimpleTestCase picklable for parallel tests using subtests.
        """
        ...
    
    def debug(self):
        """Perform the same as __call__(), without catching the exception."""
        ...
    
    if not PY311:
        @classmethod
        def enterClassContext(cls, cm):
            ...
        
    def settings(self, **kwargs):
        """
        A context manager that temporarily sets a setting and reverts to the
        original value when exiting the context.
        """
        ...
    
    def modify_settings(self, **kwargs):
        """
        A context manager that temporarily applies changes a list setting and
        reverts back to the original value when exiting the context.
        """
        ...
    
    def assertRedirects(self, response, expected_url, status_code=..., target_status_code=..., msg_prefix=..., fetch_redirect_response=...):
        """
        Assert that a response redirected to a specific URL and that the
        redirect URL can be loaded.

        Won't work for external links since it uses the test client to do a
        request (use fetch_redirect_response=False to check such links without
        fetching them).
        """
        ...
    
    def assertURLEqual(self, url1, url2, msg_prefix=...):
        """
        Assert that two URLs are the same, ignoring the order of query string
        parameters except for parameters with the same name.

        For example, /path/?x=1&y=2 is equal to /path/?y=2&x=1, but
        /path/?a=1&a=2 isn't equal to /path/?a=2&a=1.
        """
        ...
    
    def assertContains(self, response, text, count=..., status_code=..., msg_prefix=..., html=...):
        """
        Assert that a response indicates that some content was retrieved
        successfully, (i.e., the HTTP status code was as expected) and that
        ``text`` occurs ``count`` times in the content of the response.
        If ``count`` is None, the count doesn't matter - the assertion is true
        if the text occurs at least once in the response.
        """
        ...
    
    def assertNotContains(self, response, text, status_code=..., msg_prefix=..., html=...):
        """
        Assert that a response indicates that some content was retrieved
        successfully, (i.e., the HTTP status code was as expected) and that
        ``text`` doesn't occur in the content of the response.
        """
        ...
    
    def assertFormError(self, form, field, errors, msg_prefix=...):
        """
        Assert that a field named "field" on the given form object has specific
        errors.

        errors can be either a single error message or a list of errors
        messages. Using errors=[] test that the field has no errors.

        You can pass field=None to check the form's non-field errors.
        """
        ...
    
    def assertFormSetError(self, formset, form_index, field, errors, msg_prefix=...):
        """
        Similar to assertFormError() but for formsets.

        Use form_index=None to check the formset's non-form errors (in that
        case, you must also use field=None).
        Otherwise use an integer to check the formset's n-th form for errors.

        Other parameters are the same as assertFormError().
        """
        ...
    
    def assertTemplateUsed(self, response=..., template_name=..., msg_prefix=..., count=...):
        """
        Assert that the template with the provided name was used in rendering
        the response. Also usable as context manager.
        """
        ...
    
    def assertTemplateNotUsed(self, response=..., template_name=..., msg_prefix=...):
        """
        Assert that the template with the provided name was NOT used in
        rendering the response. Also usable as context manager.
        """
        ...
    
    def assertRaisesMessage(self, expected_exception, expected_message, *args, **kwargs):
        """
        Assert that expected_message is found in the message of a raised
        exception.

        Args:
            expected_exception: Exception class expected to be raised.
            expected_message: expected error message string value.
            args: Function to be called and extra positional args.
            kwargs: Extra kwargs.
        """
        ...
    
    def assertWarnsMessage(self, expected_warning, expected_message, *args, **kwargs):
        """
        Same as assertRaisesMessage but for assertWarns() instead of
        assertRaises().
        """
        ...
    
    def assertFieldOutput(self, fieldclass, valid, invalid, field_args=..., field_kwargs=..., empty_value=...):
        """
        Assert that a form field behaves correctly with various inputs.

        Args:
            fieldclass: the class of the field to be tested.
            valid: a dictionary mapping valid inputs to their expected
                    cleaned values.
            invalid: a dictionary mapping invalid inputs to one or more
                    raised error messages.
            field_args: the args passed to instantiate the field
            field_kwargs: the kwargs passed to instantiate the field
            empty_value: the expected clean output for inputs in empty_values
        """
        ...
    
    def assertHTMLEqual(self, html1, html2, msg=...):
        """
        Assert that two HTML snippets are semantically the same.
        Whitespace in most cases is ignored, and attribute ordering is not
        significant. The arguments must be valid HTML.
        """
        ...
    
    def assertHTMLNotEqual(self, html1, html2, msg=...):
        """Assert that two HTML snippets are not semantically equivalent."""
        ...
    
    def assertInHTML(self, needle, haystack, count=..., msg_prefix=...):
        ...
    
    def assertNotInHTML(self, needle, haystack, msg_prefix=...):
        ...
    
    def assertJSONEqual(self, raw, expected_data, msg=...):
        """
        Assert that the JSON fragments raw and expected_data are equal.
        Usual JSON non-significant whitespace rules apply as the heavyweight
        is delegated to the json library.
        """
        ...
    
    def assertJSONNotEqual(self, raw, expected_data, msg=...):
        """
        Assert that the JSON fragments raw and expected_data are not equal.
        Usual JSON non-significant whitespace rules apply as the heavyweight
        is delegated to the json library.
        """
        ...
    
    def assertXMLEqual(self, xml1, xml2, msg=...):
        """
        Assert that two XML snippets are semantically the same.
        Whitespace in most cases is ignored and attribute ordering is not
        significant. The arguments must be valid XML.
        """
        ...
    
    def assertXMLNotEqual(self, xml1, xml2, msg=...):
        """
        Assert that two XML snippets are not semantically equivalent.
        Whitespace in most cases is ignored and attribute ordering is not
        significant. The arguments must be valid XML.
        """
        ...
    


class TransactionTestCase(SimpleTestCase):
    reset_sequences = ...
    available_apps = ...
    fixtures = ...
    databases = ...
    _disallowed_database_msg = ...
    serialized_rollback = ...
    def assertQuerySetEqual(self, qs, values, transform=..., ordered=..., msg=...):
        ...
    
    def assertNumQueries(self, num, func=..., *args, using=..., **kwargs):
        ...
    


def connections_support_transactions(aliases=...):
    """
    Return whether or not all (or specified) connections support
    transactions.
    """
    ...

def connections_support_savepoints(aliases=...):
    """
    Return whether or not all (or specified) connections support savepoints.
    """
    ...

class TestData:
    """
    Descriptor to provide TestCase instance isolation for attributes assigned
    during the setUpTestData() phase.

    Allow safe alteration of objects assigned in setUpTestData() by test
    methods by exposing deep copies instead of the original objects.

    Objects are deep copied using a memo kept on the test case instance in
    order to maintain their original relationships.
    """
    memo_attr = ...
    def __init__(self, name, data) -> None:
        ...
    
    def get_memo(self, testcase):
        ...
    
    def __get__(self, instance, owner):
        ...
    
    def __repr__(self):
        ...
    


class TestCase(TransactionTestCase):
    """
    Similar to TransactionTestCase, but use `transaction.atomic()` to achieve
    test isolation.

    In most situations, TestCase should be preferred to TransactionTestCase as
    it allows faster execution. However, there are some situations where using
    TransactionTestCase might be necessary (e.g. testing some transactional
    behavior).

    On database backends with no transaction support, TestCase behaves as
    TransactionTestCase.
    """
    @classmethod
    def setUpClass(cls):
        ...
    
    @classmethod
    def tearDownClass(cls):
        ...
    
    @classmethod
    def setUpTestData(cls):
        """Load initial data for the TestCase."""
        ...
    
    @classmethod
    @contextmanager
    def captureOnCommitCallbacks(cls, *, using=..., execute=...):
        """Context manager to capture transaction.on_commit() callbacks."""
        ...
    


class CheckCondition:
    """Descriptor class for deferred condition checking."""
    def __init__(self, *conditions) -> None:
        ...
    
    def add_condition(self, condition, reason):
        ...
    
    def __get__(self, instance, cls=...):
        ...
    


def skipIfDBFeature(*features):
    """Skip a test if a database has at least one of the named features."""
    ...

def skipUnlessDBFeature(*features):
    """Skip a test unless a database has all the named features."""
    ...

def skipUnlessAnyDBFeature(*features):
    """Skip a test unless a database has any of the named features."""
    ...

class QuietWSGIRequestHandler(WSGIRequestHandler):
    """
    A WSGIRequestHandler that doesn't log to standard output any of the
    requests received, so as to not clutter the test result output.
    """
    def log_message(*args):
        ...
    


class FSFilesHandler(WSGIHandler):
    """
    WSGI middleware that intercepts calls to a directory, as defined by one of
    the *_ROOT settings, and serves those files, publishing them under *_URL.
    """
    def __init__(self, application) -> None:
        ...
    
    def file_path(self, url):
        """Return the relative path to the file on disk for the given URL."""
        ...
    
    def get_response(self, request):
        ...
    
    def serve(self, request):
        ...
    
    def __call__(self, environ, start_response):
        ...
    


class _StaticFilesHandler(FSFilesHandler):
    """
    Handler for serving static files. A private class that is meant to be used
    solely as a convenience by LiveServerThread.
    """
    def get_base_dir(self):
        ...
    
    def get_base_url(self):
        ...
    


class _MediaFilesHandler(FSFilesHandler):
    """
    Handler for serving the media files. A private class that is meant to be
    used solely as a convenience by LiveServerThread.
    """
    def get_base_dir(self):
        ...
    
    def get_base_url(self):
        ...
    


class LiveServerThread(threading.Thread):
    """Thread for running a live HTTP server while the tests are running."""
    server_class = ThreadedWSGIServer
    def __init__(self, host, static_handler, connections_override=..., port=...) -> None:
        ...
    
    def run(self):
        """
        Set up the live server and databases, and then loop over handling
        HTTP requests.
        """
        ...
    
    def terminate(self):
        ...
    


class LiveServerTestCase(TransactionTestCase):
    """
    Do basically the same as TransactionTestCase but also launch a live HTTP
    server in a separate thread so that the tests may use another testing
    framework, such as Selenium for example, instead of the built-in dummy
    client.
    It inherits from TransactionTestCase instead of TestCase because the
    threads don't share the same transactions (unless if using in-memory sqlite)
    and each thread needs to commit all their transactions so that the other
    thread can see the changes.
    """
    host = ...
    port = ...
    server_thread_class = LiveServerThread
    static_handler = _StaticFilesHandler
    @classproperty
    def live_server_url(cls):
        ...
    
    @classproperty
    def allowed_host(cls):
        ...
    
    @classmethod
    def setUpClass(cls):
        ...
    


class SerializeMixin:
    """
    Enforce serialization of TestCases that share a common resource.

    Define a common 'lockfile' for each set of TestCases to serialize. This
    file must exist on the filesystem.

    Place it early in the MRO in order to isolate setUpClass()/tearDownClass().
    """
    lockfile = ...
    def __init_subclass__(cls, /, **kwargs):
        ...
    
    @classmethod
    def setUpClass(cls):
        ...
    


